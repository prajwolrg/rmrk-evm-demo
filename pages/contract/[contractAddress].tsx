import NftList from "../nft-list"
import React, { useEffect, useState } from "react"
import { useRouter } from "next/router"
import { Contract, ethers, Signer } from "ethers"
import { useSigner } from "wagmi"
import { ConnectButton, useAddRecentTransaction } from "@rainbow-me/rainbowkit"
import { NextPage } from "next"
import styles from "../../styles/Home.module.css"
import Head from "next/head"
import Resource from "../../components/resource"
import abis from "../../abis/abis"

const MultiResourceNftCollection: NextPage = () => {
  const router = useRouter()
  const { contractAddress } = router.query
  let multiResourceContract: Contract
  const addRecentTransaction = useAddRecentTransaction()
  const { data: signer, isSuccess } = useSigner()
  const [currentRmrkDeployment, setCurrentRmrkDeployment] = useState<string>("")
  const [allResourcesData, setAllResourcesData] = useState<string[]>([])
  const [resources, setResources] = useState<string[]>([])
  const [resourceInput, setResourceInput] = useState<string>("")
  const [collectionName, setCollectionName] = useState<string>("")
  const [ownedNfts, setOwnedNfts] = useState<
    { tokenId: number; owner: string; tokenUri: string }[]
  >([])

  useEffect(() => {
    console.log("Loading chain data")
    console.log(currentRmrkDeployment)
    if (ethers.utils.isAddress(contractAddress as string)) {
      setCurrentRmrkDeployment(contractAddress as string)
      getOwnedNfts().then((nfts) => {
        setOwnedNfts(nfts)
      })
    }
  }, [signer, contractAddress])

  async function fetchNftCollection() {
    if (signer instanceof Signer) {
      multiResourceContract = new Contract(
        contractAddress as string,
        abis.multiResourceAbi,
        signer
      )
      const name: string = await multiResourceContract.name()
      const allResources: string[] =
        await multiResourceContract.getAllResources()
      const allData: string[] = []
      for (const r of allResources) {
        const resourceData = await multiResourceContract.getResource(r)
        allData.push(resourceData)
      }
      setAllResourcesData(allData)
      setResources(allResources)
      setCollectionName(name)
    }
  }

  async function getOwnedNfts() {
    const nfts = []

    if (
      signer instanceof Signer &&
      ethers.utils.isAddress(currentRmrkDeployment)
    ) {
      multiResourceContract = new Contract(
        currentRmrkDeployment,
        abis.multiResourceAbi,
        signer
      )
      const nftSupply = await multiResourceContract.totalSupply()
      for (let i = 0; i < nftSupply; i++) {
        let isOwner = false
        try {
          isOwner =
            (await multiResourceContract.connect(signer).ownerOf(i)) ==
            (await signer.getAddress())
        } catch (error) {
          console.log(error)
        }
        if (isOwner) {
          nfts.push({
            tokenId: i,
            owner: await signer.getAddress(),
            tokenUri: await multiResourceContract.tokenURI(i),
          })
        }
      }
    }
    return nfts
  }

  async function mintNft() {
    if (
      signer instanceof Signer &&
      ethers.utils.isAddress(currentRmrkDeployment)
    ) {
      multiResourceContract = new Contract(
        currentRmrkDeployment,
        abis.multiResourceAbi,
        signer
      )

      const options = {
        value: multiResourceContract.pricePerMint(),
      }
      const tx = await multiResourceContract
        .connect(signer)
        .mint(await signer.getAddress(), 1, options)

      addRecentTransaction({
        hash: tx.hash,
        description: "Minting a new RMRK NFT",
        confirmations: 1,
      })
    }
  }

  async function addResource() {
    if (signer instanceof Signer) {
      multiResourceContract = new Contract(
        currentRmrkDeployment,
        abis.multiResourceAbi,
        signer
      )
      const tx = await multiResourceContract
        .connect(signer) //TODO FIXME add auto incrementing IDs to resources in Multi Resource factory
        //resource IDs are randomized for now as a temporary solution
        .addResourceEntry(Math.floor(Math.random() * 999999), resourceInput, [])
      addRecentTransaction({
        hash: tx.hash,
        description: "Adding a new resource to collection",
        confirmations: 1,
      })
    }
  }

  function handleResourceInput(e: React.ChangeEvent<HTMLInputElement>) {
    setResourceInput(e.target.value)
  }

  return (
    <div className={styles.container}>
      <Head>
        <title>RMRK Multi-resource App</title>
        <meta
          name="description"
          content="Generated by @rainbow-me/create-rainbowkit"
        />
        {/*<link rel="icon" href="/favicon.ico" />*/}
      </Head>

      <main className={styles.main}>
        <ConnectButton />

        <h4 className={styles.description}>
          Collection name: {collectionName}
        </h4>
        <ul className="mt-1">Usage Notes:</ul>
        <li>
          You have to be the Owner of the NFT Collection to add new resources
        </li>
        <li>
          If you are not authorized like above the transactions will be reverted
        </li>

        <p className="mb-4 mt-5">
          Mint an NFT to be able to attach multiple resources to it:
        </p>
        <button
          onClick={() => {
            mintNft().then((r) => getOwnedNfts())
          }}
          className="btn btn-wide btn-primary"
        >
          Mint NFT
        </button>
        <p className="mt-5">
          It might take a few minutes to show your NFTs when just minted.
        </p>
        <p className="mb-5">
          Click on the NFT card to open resource management page.
        </p>
        <NftList nfts={ownedNfts} tokenContract={currentRmrkDeployment} />

        <p className="text-center text-2xl mt-10">NFT Collection Resources:</p>
        {resources.map((resource, index) => {
          return (
            <div key={index} className={styles.card}>
              <Resource
                key={index}
                resource={resource}
                strings={allResourcesData}
                index={index}
              />
            </div>
          )
        })}
        <input
          inputMode="text"
          placeholder="Resource metadata URI"
          className="input input-bordered w-full max-w-xs mt-4 mb-2"
          value={resourceInput}
          onChange={handleResourceInput}
        ></input>
        <button
          className="btn btn-primary mt-2"
          onClick={() => {
            addResource().then(() => fetchNftCollection())
          }}
        >
          Add New Resource
        </button>
      </main>
      <footer className={styles.footer}></footer>
    </div>
  )
}

export default MultiResourceNftCollection
